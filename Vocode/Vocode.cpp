//-----------------------------------------------------------------------------
// Entaro ChucK Developer!
// This is a Chugin boilerplate, generated by chugerate!
//-----------------------------------------------------------------------------

// this should align with the correct versions of these ChucK files
#include "chuck_dl.h"
#include "chuck_def.h"
#include "Ougens.h"

// general includes
#include <stdio.h>
#include <limits.h>

#define kMinCenterFreq 20.0f
#define CLIP(a, lo, hi) ( (a)>(lo)?( (a)<(hi)?(a):(hi) ):(lo) )

#define DEF_LOWFREQ   60
#define DEF_BANDWIDTH 500

// declaration of chugin constructor
CK_DLL_CTOR(vocode_ctor);
// declaration of chugin desctructor
CK_DLL_DTOR(vocode_dtor);

// example of getter/setter
CK_DLL_MFUN(vocode_setLowfreq);
CK_DLL_MFUN(vocode_setHighfreq);
CK_DLL_MFUN(vocode_setBandwidth);
CK_DLL_MFUN(vocode_setHold);
CK_DLL_MFUN(vocode_setResponsetime);
CK_DLL_MFUN(vocode_setModQ);
CK_DLL_MFUN(vocode_setCarQ);
CK_DLL_MFUN(vocode_setModTranspose);
CK_DLL_MFUN(vocode_setCarTranspose);

// for Chugins extending UGen, this is mono synthesis function for 1 sample
CK_DLL_TICKF(vocode_tick);

// this is a special offset reserved for Chugin internal data
t_CKINT vocode_data_offset = 0;

const OeqType kBandPassType = OeqBandPassCPG;  // constant 0 dB peak gain

// class definition for internal Chugin data
// (note: this isn't strictly necessary, but serves as example
// of one recommended approach)
class Vocode
{
public:
  // constructor
  Vocode( t_CKFLOAT fs)
  {
	_srate = fs;
    _hold = false;
    _responsetime = 0.01*fs;
    _nyquist = fs * 0.5f;
	_lowfreq = DEF_LOWFREQ;
	_highfreq = fs * 0.5f;
	_bandwidth = DEF_BANDWIDTH;
	_modtransp = 1;
	_cartransp = 1;
	_modq = 1;
	_carq = 1;
	adjustBands();
  }

  ~Vocode()
  {
    delete [] _maptable;
	delete [] _modtable;
	delete [] _cartable;
    delete [] _lastmod;
    
    for (int i = 0; i < _numfilts; i++)
	  {
		delete _modulator_filt[i];
		delete _carrier_filt[i];
		delete _balancer[i];
	  }
    delete [] _modulator_filt;
    delete [] _carrier_filt;
    delete [] _balancer;
  }
  
  // for Chugins extending UGen
  void tick( SAMPLE* in, SAMPLE* out, int nframes)
  {
    // default: this passes whatever input is patched into Chugin
    const int samps =  2;

    const float carsig = in[0];
    const float modsig = in[1];
	memset (out, 0, sizeof(SAMPLE)*2);
    out[0] = 0.0f;
    out[1] = 0.0f;
    
    for (int j = 0; j < _numfilts; j++)
      {
		float mod;
		if (_hold)
		  mod = _lastmod[j];
		else
		  mod = _modulator_filt[j]->next(modsig);
		float car = _carrier_filt[j]->next(carsig);
		float balsig = _balancer[j]->next(car, mod);
		out[0] += balsig;
      }
  }

  int setHold (t_CKINT x)
  {
	if (x)
	  {
		_hold = true;
		for (int i = 0; i < _numfilts; i++)
		  {
			_lastmod[i] = _modulator_filt[i]->last();
		  }
	  }
	else _hold = false;
	return x;
  }

  float setResponsetime ( t_CKDUR x)
  {
	if (x == _responsetime)
	  return x;
	_responsetime = x;
	int windowlen = int(_responsetime + 0.5f);
	if (windowlen < 2)   // otherwise, can get ear-splitting output
	  windowlen = 2;
	for (int i = 0; i < _numfilts; i++)
	  _balancer[i]->setwindow(windowlen);
	return _responsetime;
  }

  float setBandwidth ( t_CKFLOAT x)
  {
	if (x == _bandwidth)
	  return x;
	_bandwidth = x;
	adjustBands();
	return _bandwidth;
  }

  float setLowfreq ( t_CKFLOAT x)
  {
	if (x == _lowfreq)
	  return x;
	_lowfreq = CLIP(x,0,_nyquist);
	adjustBands();
	return _lowfreq;
  }

  float setHighfreq ( t_CKFLOAT x)
  {
	if (x == _highfreq)
	  return x;
	_highfreq = CLIP(x,0,_nyquist);
	adjustBands();
	return _highfreq;
  }

  float setModQ ( t_CKFLOAT x)
  {
	if (x == _modq)
	  return x;
	_modq = CLIP(x,0,_srate);
	adjustBands();
	return _modq;
  }

  float setCarQ ( t_CKFLOAT x)
  {
	if (x == _carq)
	  return x;
	_carq = CLIP(x,0,_srate);
	adjustBands();
	return _carq;
  }

  float setModTranspose ( t_CKFLOAT x)
  {
	if (x == _modtransp)
	  return x;
	_modtransp = CLIP(x,0,_srate);
	adjustBands();
	return _modtransp;
  }

  float setCarTranspose ( t_CKFLOAT x)
  {
	if (x == _cartransp)
	  return x;
	_cartransp = CLIP(x,0,_srate);
	adjustBands();
	return _cartransp;
  }	
  
private:
  void adjustBands()
  {
	if (_lowfreq > _highfreq) swap2(_lowfreq, _highfreq);
	int temp = (int)((_highfreq - _lowfreq)/_bandwidth);
	if (!_numfilts || temp != _numfilts)
	  {
		_numfilts = temp;

		_maptable = new int [_numfilts];
		_modtable = new float [_numfilts];
		_cartable = new float [_numfilts];
		_lastmod = new float [_numfilts];
		_modulator_filt = new Oequalizer * [_numfilts];
		_carrier_filt = new Oequalizer * [_numfilts];
		_balancer = new Obalance * [_numfilts];
	  }
	for (int i = 0; i < _numfilts; i++)
	  {
		_maptable[i] = 0;
		// TODO: Maybe separate these later?
		_modtable[i] = _lowfreq + i*_bandwidth;
		_cartable[i] = _lowfreq + i*_bandwidth;
		_modulator_filt[i] = new Oequalizer(_srate, kBandPassType);
		float mfreq = _modtable[i] * _modtransp;
		_modulator_filt[i]->setparams(mfreq, _modq);
		
		_carrier_filt[i] = new Oequalizer(_srate, kBandPassType);
		float cfreq = _cartable[i] * _cartransp;
		_carrier_filt[i]->setparams(cfreq, _carq);
		
		_balancer[i] = new Obalance(_srate);
		
		_lastmod[i] = 0.0f;	// not necessary
	  }
  }

  // instance data
  float _srate;
  int _numfilts;
  bool _hold;
  float _lowfreq, _highfreq, _bandwidth;
  int *_maptable;
  float _modtransp, _cartransp, _modq, _carq, _responsetime;
  float _amp, _pan, _nyquist;
  float* _lastmod;
  float *_modtable, *_cartable;
  Oequalizer **_modulator_filt, **_carrier_filt;
  Obalance **_balancer;

  int usage();
  inline float convertSmooth(const float smooth);
  inline void swap2( float& a, float& b )
  {
	float temp = a;
	a = b;
	b = temp;
  }
};


// query function: chuck calls this when loading the Chugin
// NOTE: developer will need to modify this function to
// add additional functions to this Chugin
CK_DLL_QUERY( Vocode )
{
  // hmm, don't change this...
  QUERY->setname(QUERY, "Vocode");
  
  // begin the class definition
  // can change the second argument to extend a different ChucK class
  QUERY->begin_class(QUERY, "Vocode", "UGen");
  
  // register the constructor (probably no need to change)
  QUERY->add_ctor(QUERY, vocode_ctor);
  // register the destructor (probably no need to change)
  QUERY->add_dtor(QUERY, vocode_dtor);
  
    QUERY->add_ugen_funcf(QUERY, vocode_tick, NULL, 2, 2);
    
  QUERY->add_mfun(QUERY, vocode_setLowfreq, "float", "low");
  QUERY->add_arg(QUERY, "float", "freq");

  QUERY->add_mfun(QUERY, vocode_setHighfreq, "float", "high");
  QUERY->add_arg(QUERY, "float", "freq");

  QUERY->add_mfun(QUERY, vocode_setBandwidth, "float", "width");
  QUERY->add_arg(QUERY, "float", "width");

  QUERY->add_mfun(QUERY, vocode_setHold, "int", "hold");
  QUERY->add_arg(QUERY, "int", "hold");

  QUERY->add_mfun(QUERY, vocode_setResponsetime, "dur", "response");
  QUERY->add_arg(QUERY, "dur", "response");

  QUERY->add_mfun(QUERY, vocode_setModQ, "float", "modQ");
  QUERY->add_arg(QUERY, "float", "modq");

  QUERY->add_mfun(QUERY, vocode_setCarQ, "float", "carQ");
  QUERY->add_arg(QUERY, "float", "carq");

  QUERY->add_mfun(QUERY, vocode_setModTranspose, "float", "modTranspose");
  QUERY->add_arg(QUERY, "float", "modtrans");

  QUERY->add_mfun(QUERY, vocode_setCarTranspose, "float", "carTranspose");
  QUERY->add_arg(QUERY, "float", "cartrans");
  
  // this reserves a variable in the ChucK internal class to store 
  // referene to the c++ class we defined above
  vocode_data_offset = QUERY->add_mvar(QUERY, "int", "@v_data", false);
  QUERY->end_class(QUERY);
  return TRUE;
}


// implementation for the constructor
CK_DLL_CTOR(vocode_ctor)
{
  // get the offset where we'll store our internal c++ class pointer
  OBJ_MEMBER_INT(SELF, vocode_data_offset) = 0;
  
  // instantiate our internal c++ class representation
  Vocode * bcdata = new Vocode(API->vm->get_srate());
  
  // store the pointer in the ChucK object member
  OBJ_MEMBER_INT(SELF, vocode_data_offset) = (t_CKINT) bcdata;
}


// implementation for the destructor
CK_DLL_DTOR(vocode_dtor)
{
  // get our c++ class pointer
  Vocode * bcdata = (Vocode *) OBJ_MEMBER_INT(SELF, vocode_data_offset);
  // check it
  if( bcdata )
    {
      // clean up
      delete bcdata;
      OBJ_MEMBER_INT(SELF, vocode_data_offset) = 0;
      bcdata = NULL;
    }
}


// implementation for tick function
CK_DLL_TICKF(vocode_tick)
{
  // get our c++ class pointer
  Vocode * c = (Vocode *) OBJ_MEMBER_INT(SELF, vocode_data_offset);
  
  // invoke our tick function; store in the magical out variable
  if(c) c->tick(in,out, nframes);

  // yes
  return TRUE;
}

CK_DLL_MFUN(vocode_setLowfreq)
{
  // get our c++ class pointer
  Vocode * bcdata = (Vocode *) OBJ_MEMBER_INT(SELF, vocode_data_offset);
  // set the return value
  RETURN->v_float = bcdata->setLowfreq(GET_NEXT_FLOAT(ARGS));
}

CK_DLL_MFUN(vocode_setHighfreq)
{
  // get our c++ class pointer
  Vocode * bcdata = (Vocode *) OBJ_MEMBER_INT(SELF, vocode_data_offset);
  // set the return value
  RETURN->v_float = bcdata->setHighfreq(GET_NEXT_FLOAT(ARGS));
}

CK_DLL_MFUN(vocode_setBandwidth)
{
  // get our c++ class pointer
  Vocode * bcdata = (Vocode *) OBJ_MEMBER_INT(SELF, vocode_data_offset);
  // set the return value
  RETURN->v_float = bcdata->setBandwidth(GET_NEXT_FLOAT(ARGS));
}

CK_DLL_MFUN(vocode_setHold)
{
  // get our c++ class pointer
  Vocode * bcdata = (Vocode *) OBJ_MEMBER_INT(SELF, vocode_data_offset);
  // set the return value
  RETURN->v_int = bcdata->setLowfreq(GET_NEXT_INT(ARGS));
}

CK_DLL_MFUN(vocode_setResponsetime)
{
  // get our c++ class pointer
  Vocode * bcdata = (Vocode *) OBJ_MEMBER_INT(SELF, vocode_data_offset);
  // set the return value
  RETURN->v_dur = bcdata->setResponsetime(GET_NEXT_DUR(ARGS));
}

CK_DLL_MFUN(vocode_setModQ)
{
  // get our c++ class pointer
  Vocode * bcdata = (Vocode *) OBJ_MEMBER_INT(SELF, vocode_data_offset);
  // set the return value
  RETURN->v_float = bcdata->setModQ(GET_NEXT_FLOAT(ARGS));
}

CK_DLL_MFUN(vocode_setCarQ)
{
  // get our c++ class pointer
  Vocode * bcdata = (Vocode *) OBJ_MEMBER_INT(SELF, vocode_data_offset);
  // set the return value
  RETURN->v_float = bcdata->setCarQ(GET_NEXT_FLOAT(ARGS));
}

CK_DLL_MFUN(vocode_setModTranspose)
{
  // get our c++ class pointer
  Vocode * bcdata = (Vocode *) OBJ_MEMBER_INT(SELF, vocode_data_offset);
  // set the return value
  RETURN->v_float = bcdata->setModTranspose(GET_NEXT_FLOAT(ARGS));
}

CK_DLL_MFUN(vocode_setCarTranspose)
{
  // get our c++ class pointer
  Vocode * bcdata = (Vocode *) OBJ_MEMBER_INT(SELF, vocode_data_offset);
  // set the return value
  RETURN->v_float = bcdata->setCarTranspose(GET_NEXT_FLOAT(ARGS));
}
